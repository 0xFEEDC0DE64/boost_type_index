[library Boost.TypeIndex
    [quickbook 1.5]
    [version 1.0]
    [copyright 2012-2013 Antony Polukhin]
    [category Language Features Emulation]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section Motivation]
Sometimes getting and storing information about a type at runtime is required. For such cases a construction like `&typeid(T)` or C++11 class `std::type_index` is usually used. And that is the point, where problems start:

* `typeid(T)` and `std::type_index` require Run Time Type Info (RTTI)
* some implementations of `typeid(T)` strip const, volatile and references from type, while others don't
* some compilers have bugs and do not correctly compare `std::type_info` objects across shared libraries
* only a few implementations of Standard Library currently provide `std::type_index`
* no easy way to store type info without stripping const, volatile and references
* no nice and portable way to get human readable type names

Boost.TypeIndex was designed to work around all those issues.

ï»¿[note `T` means type here. Think of it as of `T` in `template <class T>` ] 

[warning This library is not accepted to Boost, it is currrently waiting for review. ] 

[endsect]

[section Getting started]

`boost::type_index` can be used as a drop-in replacement for `std::type_index`, but 
it usually does not require RTTI. It provides the full set of comparison operators, 
hashing functions and ostream operators, so it can be used with any container class.

To start using it:

* Replace `std::type_index`, `const std::type_info&`, `const std::type_info*` with `boost::type_index`.
* If you do not want to save `const`, `volatile`, `&` and `&&`:
    * Use `boost::type_id<T>()` instead of `typeid(T)`, `&typeid(T)`.
* If you want to save `const`, `volatile`, `&` and `&&`:
    * Use `boost::type_id_with_cvr<T>()` instead of `typeid(T)`, `&typeid(T)`.
* To get nice human readable names, use the `name_demangled()` member function:
``
#include <boost/type_index/type_index_minimal.hpp>

type_index ti = type_id<T>();
std::string nice_name 
    = ti.name_demangled();
...
std::string nice_name_with_const_volatile_ref 
    = type_id_with_cvr<ParamT&>().name_demangled();
``

[endsect]


[section Examples]

[import ../examples/demangled_names.cpp]
[section Getting human readable and mangled type names] [type_index_names_example] [endsect]

[import ../examples/registry.cpp]
[section Storing information about a type in container ] [type_index_registry_example] [endsect]

[import ../examples/inheritance.cpp]
[section Getting through the inheritance to receive a real type name ] [type_index_derived_example] [endsect]

[import ../examples/exact_types_match.cpp]
[section Exact type match: storing type with const, volatile and reference ] [type_index_exact_type_match_example] [endsect]

[endsect]

[xinclude autodoc.xml]

[section Space and Performance]

* `template_index` uses the `BOOST_CURRENT_FUNCTION` macro which could lead to code bloat, so prefer using `type_index` type.
* `type_index` and `template_index` classes hold a single pointer, so they are easy and fast to copy. 
* Calls to `const char* name()` do not require dynamic memory allocation and usually just return a pointer to an array of chars in a read-only section of the binary image. 
* Comparison operators are optimized as much as possible, and will at worst execute a single `std::strcmp`. 
* Calls to `std::string name_demangled()` for `type_index` do usually require dynamic memory allocation and some computations, so they are not recomended for usage in performance critical sections. 
* Calls to `std::string name_demangled()` for `template_index` only require a single `std::strlen` call and are considerably faster than `std::string name_demangled()` for `type_index`.

[endsect]

[section Code bloat]

Without RTTI TypeIndex library will switch from using `boost::type_index` class to `boost::template_index`. `boost::template_index` uses the `BOOST_CURRENT_FUNCTION` for each type that is passed to `type_id()` and `type_id_with_cvr()`
functions. 

This leads to big strings in binary file:
```
static const char* boost::detail::ctti<T>::n() [with T = int]
static const char* boost::detail::ctti<T>::n() [with T = user_defined_type]
```
While using RTTI, you'll get the following (more compact) string in binary file: 

```
i
17user_defined_type
```

[endsect]

[section Compiler support]

TypeIndex has been tested and sucessfully work on MSVC2010, GCC-4.5, Clang-2.9. If your compiler is not in a list of tested compilers, you shall correctly define `BOOST_TYPE_INDEX_CTTI_BEGIN_SKIP` and `BOOST_TYPE_INDEX_CTTI_END_SKIP` macroses:

# define `BOOST_TYPE_INDEX_CTTI_BEGIN_SKIP` and `BOOST_TYPE_INDEX_CTTI_END_SKIP` to `0`
# get the output of `boost::detail::ctti<int>::n()`
# set `BOOST_TYPE_INDEX_CTTI_BEGIN_SKIP` equal to characters count before last occurrence of `int` in output
# set `BOOST_TYPE_INDEX_CTTI_END_SKIP`  equal to characters count after last occurrence of `int` in output
# check that `boost::detail::ctti<int>::name_demangled()` returns "int"
# (optional, but highly recomended) [@http://www.boost.org/support/bugs.html create ticket] with feature request to add your compiler to supported compilers list. Include `BOOST_TYPE_INDEX_CTTI_BEGIN_SKIP` and `BOOST_TYPE_INDEX_CTTI_END_SKIP` numbers.  

Consider the following example:
With `BOOST_TYPE_INDEX_CTTI_BEGIN_SKIP` and `BOOST_TYPE_INDEX_CTTI_END_SKIP` set to `0`, `boost::detail::ctti<int>::n()` returns "const char *__cdecl boost::detail::ctti<int>::n(void)". Then you shall set `BOOST_TYPE_INDEX_CTTI_BEGIN_SKIP` to `sizeof("const char *__cdecl boost::detail::ctti<") - 1` and `BOOST_TYPE_INDEX_CTTI_END_SKIP` to `sizeof(">::n(void)") - 1`

[endsect]
