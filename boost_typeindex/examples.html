<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Examples</title>
<link rel="stylesheet" href="http://www.boost.org/doc/libs/1_53_0/doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.TypeIndex 3.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.TypeIndex 3.0">
<link rel="prev" href="how_it_works.html" title="How it works">
<link rel="next" href="../boost_typeindex_header_reference.html" title="Boost.TypeIndex Header Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="http://www.boost.org/doc/libs/1_53_0/boost.png"></td>
<td align="center"><a href="http://www.boost.org/doc/libs/1_53_0/index.html">Home</a></td>
<td align="center"><a href="http://www.boost.org/doc/libs/1_53_0/libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="http://www.boost.org/doc/libs/1_53_0/more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="how_it_works.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../boost_typeindex_header_reference.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_typeindex.examples"></a><a class="link" href="examples.html" title="Examples">Examples</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.getting_human_readable_and_mangl">Getting
      human readable and mangled type names</a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.storing_information_about_a_type">Storing
      information about a type in container </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.getting_through_the_inheritance_">Getting
      through the inheritance to receive a real type name </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.exact_type_match_storing_type_wi">Exact
      type match: storing type with const, volatile and reference </a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.getting_human_readable_and_mangl"></a><a class="link" href="examples.html#boost_typeindex.examples.getting_human_readable_and_mangl" title="Getting human readable and mangled type names">Getting
      human readable and mangled type names</a>
</h3></div></div></div>
<p>
        The following example shows how short (mangled) and human readable type names
        could be obtained from a type. Works with and without RTTI.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">bti</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeind</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\n Short name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">raw_name</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\n Readable name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">pretty_name</span><span class="special">();</span>
<span class="special">}</span>

<span class="keyword">struct</span> <span class="identifier">user_defined_type</span><span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">// Call to</span>
    <span class="identifier">foo</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
    <span class="comment">// will output something like this:</span>
    <span class="comment">//</span>
    <span class="comment">// (RTTI on)                            (RTTI off)</span>
    <span class="comment">// Short name: i                        Short name: int]</span>
    <span class="comment">// Readable name: int                   Readable name: int</span>

    <span class="identifier">user_defined_type</span> <span class="identifier">t</span><span class="special">;</span>
    <span class="identifier">foo</span><span class="special">(</span><span class="identifier">t</span><span class="special">);</span>
    <span class="comment">// Will output:</span>
    <span class="comment">//</span>
    <span class="comment">// (RTTI on)                            (RTTI off)</span>
    <span class="comment">// Short name: 17user_defined_type      user_defined_type]</span>
    <span class="comment">// Readable name: user_defined_type     user_defined_type</span>
<span class="special">}</span>
</pre>
<p>
        Short names are very compiler dependant: some compiler will output <code class="computeroutput"><span class="special">.</span><span class="identifier">H</span></code>, others
        <code class="computeroutput"><span class="identifier">i</span></code>.
      </p>
<p>
        Readable names may also differ between compilers: <code class="computeroutput"><span class="keyword">struct</span>
        <span class="identifier">user_defined_type</span></code>, <code class="computeroutput"><span class="identifier">user_defined_type</span></code>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.storing_information_about_a_type"></a><a class="link" href="examples.html#boost_typeindex.examples.storing_information_about_a_type" title="Storing information about a type in container">Storing
      information about a type in container </a>
</h3></div></div></div>
<p>
        The following example shows how an information about a type could be stored.
        Example works with and without RTTI.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">functional</span><span class="special">/</span><span class="identifier">hash</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">bti</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeind</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_index</span><span class="special">&gt;</span> <span class="identifier">types</span><span class="special">;</span>

    <span class="comment">// Storing some `boost::type_info`s</span>
    <span class="identifier">types</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;());</span>
    <span class="identifier">types</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;());</span>

    <span class="comment">// `types` variable contains two `boost::type_index`es:</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">types</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">2</span><span class="special">);</span>

    <span class="comment">// Const, volatile and reference will be striped from the type:</span>
    <span class="keyword">bool</span> <span class="identifier">is_inserted</span> <span class="special">=</span> <span class="identifier">types</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&gt;()).</span><span class="identifier">second</span><span class="special">;</span>
    <span class="identifier">assert</span><span class="special">(!</span><span class="identifier">is_inserted</span><span class="special">);</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">types</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&amp;&gt;())</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>

    <span class="comment">// We have erased the `float` type, only `int` remains</span>
    <span class="identifier">assert</span><span class="special">(*</span><span class="identifier">types</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;());</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.getting_through_the_inheritance_"></a><a class="link" href="examples.html#boost_typeindex.examples.getting_through_the_inheritance_" title="Getting through the inheritance to receive a real type name">Getting
      through the inheritance to receive a real type name </a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">type_info</span></code>
        is able to store the real type, successfully getting through all the inheritances.
      </p>
<p>
        Example works with and without RTTI."
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">bti</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeind</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_CLASS</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">A</span><span class="special">(){}</span>
<span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">B</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">A</span> <span class="special">{</span> <span class="identifier">BOOST_TYPE_INDEX_REGISTER_CLASS</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">C</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">B</span> <span class="special">{</span> <span class="identifier">BOOST_TYPE_INDEX_REGISTER_CLASS</span> <span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">print_real_type</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id_runtime</span><span class="special">(</span><span class="identifier">a</span><span class="special">).</span><span class="identifier">pretty_name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">C</span> <span class="identifier">c</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">c_as_a</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
    <span class="identifier">print_real_type</span><span class="special">(</span><span class="identifier">c_as_a</span><span class="special">);</span>    <span class="comment">// Outputs `struct C`</span>
    <span class="identifier">print_real_type</span><span class="special">(</span><span class="identifier">B</span><span class="special">());</span>       <span class="comment">// Outputs `struct B`</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.exact_type_match_storing_type_wi"></a><a class="link" href="examples.html#boost_typeindex.examples.exact_type_match_storing_type_wi" title="Exact type match: storing type with const, volatile and reference">Exact
      type match: storing type with const, volatile and reference </a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">type_index</span></code>
        (and <code class="computeroutput"><span class="identifier">type_info</span></code>) is able to
        store the exact type, without stripping const, volatile and references. Example
        works with and without RTTI.
      </p>
<p>
        In this example we'll create a class, that stores pointer to function and
        remembers the exact type of a parameter that function accepts. When an attempt
        to call the stored function will be made, type of input parameter will be
        checked for exact match with initaily erased type of function.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">stdexcept</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">bti</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeind</span><span class="special">;</span>

<span class="keyword">class</span> <span class="identifier">type_erased_unary_function</span> <span class="special">{</span>
    <span class="keyword">void</span><span class="special">*</span>               <span class="identifier">function_ptr_</span><span class="special">;</span>
    <span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_index</span>     <span class="identifier">exact_param_t_</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ParamT</span><span class="special">&gt;</span>
    <span class="identifier">type_erased_unary_function</span><span class="special">(</span><span class="keyword">void</span><span class="special">(*</span><span class="identifier">ptr</span><span class="special">)(</span><span class="identifier">ParamT</span><span class="special">))</span>
        <span class="special">:</span> <span class="identifier">function_ptr_</span><span class="special">(</span><span class="keyword">reinterpret_cast</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">*&gt;(</span><span class="identifier">ptr</span><span class="special">))</span> <span class="comment">// ptr - is a pointer to function returning `void` and accepting parameter of type `ParamT`</span>
        <span class="special">,</span> <span class="identifier">exact_param_t_</span><span class="special">(</span><span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id_with_cvr</span><span class="special">&lt;</span><span class="identifier">ParamT</span><span class="special">&gt;())</span>
    <span class="special">{}</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ParamT</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">call</span><span class="special">(</span><span class="identifier">ParamT</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">exact_param_t_</span> <span class="special">!=</span> <span class="identifier">bti</span><span class="special">::</span><span class="identifier">type_id_with_cvr</span><span class="special">&lt;</span><span class="identifier">ParamT</span><span class="special">&gt;())</span> <span class="special">{</span>
            <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"Incorrect `ParamT`"</span><span class="special">);</span>
        <span class="special">}</span>

        <span class="keyword">return</span> <span class="special">(</span><span class="keyword">reinterpret_cast</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">(*)(</span><span class="identifier">ParamT</span><span class="special">)&gt;(</span><span class="identifier">function_ptr_</span><span class="special">))(</span><span class="identifier">v</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span><span class="special">){}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">type_erased_unary_function</span> <span class="identifier">func</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">);</span>
    <span class="identifier">func</span><span class="special">.</span><span class="identifier">call</span><span class="special">(</span><span class="number">100</span><span class="special">);</span> <span class="comment">// OK, `100` has type `int`</span>

    <span class="keyword">try</span> <span class="special">{</span>
        <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>

        <span class="comment">// An attempt to convert stored function to a function accepting reference</span>
        <span class="identifier">func</span><span class="special">.</span><span class="identifier">call</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&amp;&gt;(</span><span class="identifier">i</span><span class="special">);</span> <span class="comment">// Will throw, because types `int&amp;` and `int` missmatch</span>

        <span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
    <span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">&amp;</span> <span class="comment">/*e*/</span><span class="special">)</span> <span class="special">{}</span>
<span class="special">}</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2012-2014 Antony Polukhin<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="how_it_works.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../boost_typeindex_header_reference.html"><img src="http://www.boost.org/doc/libs/1_53_0/doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
